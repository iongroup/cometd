
[[_javascript_transports]]
=== JavaScript Transports

xref:_bayeux[The Bayeux protocol section] defines two mandatory transports: `long-polling` and `callback-polling`.

The JavaScript CometD implementation implements these two transports and supports also the `websocket` transport (based on https://en.wikipedia.org/wiki/WebSocket[WebSocket]).

==== The `long-polling` Transport

The `long-polling` transport is the default transport if the browser and the server do not support WebSockets.
This transport is used when the communication with the Bayeux server happens on the same origin, and also in the cross-origin mode for recent browsers (see also xref:_javascript_transports_cross_origin[the cross-origin section]).
The data is sent to the server by means of a POST request with `Content-Type: application/json` via a plain `XMLHttpRequest` call.

==== The `callback-polling` Transport

The `callback-polling` transport is used when the communication with the Bayeux server happens on a different origin and when the cross-origin mode is not supported (see also xref:_javascript_transports_cross_origin[the cross-origin section]).

`XMLHttpRequest` supports cross-origin invocations, but for the invocation to succeed the server must collaborate, typically by deploying a xref:_java_server_configuration_advanced[cross-origin component].

In case of older browsers or servers that do not deploy a cross-origin component, the `callback-polling` transport uses the JSONP script injection, which injects a `<script>` element whose `src` attribute points to the Bayeux server.
The browser notices the script element injection and performs a GET request to the specified source URL.
The Bayeux server is aware that this is a JSONP request and replies with a JavaScript function that the browser then executes, (and calls back into the JavaScript CometD implementation).

There are three main drawbacks in using this transport: 

* The transport is chattier.
  This is due to the fact that the browser executes the injected scripts sequentially, and until a script has been completely "downloaded", it cannot be executed.
  For example, imagine a communication that involves a script injection for the long poll, and a script injection for a message publish.
  The browser injects the long poll script, a request is made to the Bayeux server, but the Bayeux server holds the request waiting for server-side events (so the script is not downloaded).
  Then the browser injects the publish script, the request is made to the Bayeux server, which replies (so the script is downloaded).
  However, the browser does not execute the second script, because it has not executed the first yet (since its download is not finished).
  In these conditions, the publish script is executed only after the long poll script returns.
  To avoid this situation, the Bayeux server, in case of `callback-polling` transport, resumes the client's long poll for every message that arrives from that client, and that's why the transport is chattier: the long poll returns more often.
* The message size may be limited, as some browsers have a limit the number of characters of GET requests.
* The reaction to failures is slower.This is due to the fact that if the script injection points to a URL that returns an error (for example, the Bayeux server is down), the browser silently ignores the error.

==== The `websocket` Transport

The `websocket` transport is available if the browser and the server support WebSocket.
The WebSocket protocol is designed to be the bidirectional communication protocol for the web, so it is a natural fit in the CometD project.

The easiest way of enabling/disabling the `websocket` transport is to set a boolean variable _before_ performing the initial CometD handshake:

[source,javascript]
----
import {CometD} from "cometd/cometd.js";

const cometd = new CometD();

// Disable the websocket transport.
cometd.websocketEnabled = false;

// Initial handshake
cometd.init('http://localhost:8080/cometd');
----

An alternative way of disabling the `websocket` transport is to unregister its transport, see also xref:_javascript_transports_unregistering[the transport unregistering section].

[IMPORTANT]
====
Remember that enabling the `websocket` transport on the client is not enough: you must also enable it on the server.
Follow xref:_java_server_transports[the server transports section] for configuring `websocket` on the server.
====

[[_javascript_transports_unregistering]]
==== Unregistering Transports

The CometD JavaScript API allows you to unregister transports, and this can be useful to force the use of only one transport (for example, for testing purposes), or to disable certain transports that might be unreliable.
For example, it is possible to unregister the WebSocket transport by unregistering it with the following code:

[source,javascript]
----
import {CometD} from "cometd/cometd.js";

const cometd = new CometD();

cometd.unregisterTransport('websocket');
----

[[_javascript_transports_cross_origin]]
==== The Cross-Origin Mode

The cross-origin mode is in play when the CometD JavaScript files are downloaded from a _domain_ server, but the JavaScript application wants to connect to a CometD server different from the domain server, the _cross_ server.

Browsers use the https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[CORS protocol] to control whether the script downloaded from the domain server can connect to the cross server.

To use the cross-origin mode, you need to configure the cross server with a cross-origin component.
For example, Jetty can be configured with the `CrossOriginHandler` or the `CrossOriginFilter`.

With this setup, even when the communication with the Bayeux server is cross-origin, CometD uses the `long-polling` transport, avoiding the drawbacks of the `callback-polling` transport.
